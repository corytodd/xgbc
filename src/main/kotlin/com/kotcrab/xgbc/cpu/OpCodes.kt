package com.kotcrab.xgbc.cpu

import com.kotcrab.xgbc.Emulator
import com.kotcrab.xgbc.EmulatorException

/** @author Kotcrab */

fun generateOpCodes(emu: Emulator, cpu: Cpu, proc: OpCodesProcessor, op: Array<Instr?>) {
    op[0x00] = Instr(1, 4, "NOP", {})
    op[0x01] = Instr(3, 12, "LD BC, d16", { proc.ld16ImmValueToReg(Reg16.BC) })
    op[0x02] = Instr(1, 8, "LD (BC), A", { proc.ld8RegToReg16Addr(Reg16.BC, Reg.A) })
    op[0x03] = Instr(1, 8, "INC BC", { proc.inc16(Reg16.BC) })
    op[0x04] = Instr(1, 4, "INC B", { proc.inc(Reg.B) })
    op[0x05] = Instr(1, 4, "DEC B", { proc.dec(Reg.B) })
    op[0x06] = Instr(2, 8, "LD B, d8", { proc.ld8ImmValueToReg(Reg.B) })
    op[0x07] = Instr(1, 4, "RLCA", { proc.rlcReg(Reg.A, false) })
    op[0x08] = Instr(3, 20, "LD (a16), SP", { emu.write16(emu.read16(cpu.pc + 1), cpu.sp) })
    op[0x09] = Instr(1, 8, "ADD HL, BC", { proc.addHL(Reg16.BC) })
    op[0x0A] = Instr(1, 8, "LD A, (BC)", { proc.ld8Reg16AddrToReg(Reg.A, Reg16.BC) })
    op[0x0B] = Instr(1, 8, "DEC BC", { proc.dec16(Reg16.BC) })
    op[0x0C] = Instr(1, 4, "INC C", { proc.inc(Reg.C) })
    op[0x0D] = Instr(1, 4, "DEC C", { proc.dec(Reg.C) })
    op[0x0E] = Instr(2, 8, "LD C, d8", { proc.ld8ImmValueToReg(Reg.C) })
    op[0x0F] = Instr(1, 4, "RRCA", { proc.rrcReg(Reg.A, false) })
    op[0x10] = Instr(2, 4, "STOP 0", {})
    op[0x11] = Instr(3, 12, "LD DE, d16", { proc.ld16ImmValueToReg(Reg16.DE) })
    op[0x12] = Instr(1, 8, "LD (DE), A", { proc.ld8RegToReg16Addr(Reg16.DE, Reg.A) })
    op[0x13] = Instr(1, 8, "INC DE", { proc.inc16(Reg16.DE) })
    op[0x14] = Instr(1, 4, "INC D", { proc.inc(Reg.D) })
    op[0x15] = Instr(1, 4, "DEC D", { proc.dec(Reg.D) })
    op[0x16] = Instr(2, 8, "LD D, d8", { proc.ld8ImmValueToReg(Reg.D) })
    op[0x17] = Instr(1, 4, "RLA", { proc.rlReg(Reg.A, false) })
    op[0x18] = JmpInstr(2, 12, 12, "JR r8", { proc.jr() })
    op[0x19] = Instr(1, 8, "ADD HL, DE", { proc.addHL(Reg16.DE) })
    op[0x1A] = Instr(1, 8, "LD A, (DE)", { proc.ld8Reg16AddrToReg(Reg.A, Reg16.DE) })
    op[0x1B] = Instr(1, 8, "DEC DE", { proc.dec16(Reg16.DE) })
    op[0x1C] = Instr(1, 4, "INC E", { proc.inc(Reg.E) })
    op[0x1D] = Instr(1, 4, "DEC E", { proc.dec(Reg.E) })
    op[0x1E] = Instr(2, 8, "LD E, d8", { proc.ld8ImmValueToReg(Reg.E) })
    op[0x1F] = Instr(1, 4, "RRA", { proc.rrReg(Reg.A, false) })
    op[0x20] = JmpInstr(2, 12, 8, "JR NZ, r8", { proc.jrNZ() })
    op[0x21] = Instr(3, 12, "LD HL, d16", { proc.ld16ImmValueToReg(Reg16.HL) })
    op[0x22] = Instr(1, 8, "LD (HL+), A", {
        proc.ld8RegToReg16Addr(Reg16.HL, Reg.A)
        proc.inc16(Reg16.HL)
    })
    op[0x23] = Instr(1, 8, "INC HL", { proc.inc16(Reg16.HL) })
    op[0x24] = Instr(1, 4, "INC H", { proc.inc(Reg.H) })
    op[0x25] = Instr(1, 4, "DEC H", { proc.dec(Reg.H) })
    op[0x26] = Instr(2, 8, "LD H, d8", { proc.ld8ImmValueToReg(Reg.H) })
    op[0x27] = Instr(1, 4, "DAA", { proc.daa() })
    op[0x28] = JmpInstr(2, 12, 8, "JR Z, r8", { proc.jrZ() })
    op[0x29] = Instr(1, 8, "ADD HL, HL", { proc.addHL(Reg16.HL) })
    op[0x2A] = Instr(1, 8, "LD A, (HL+)", {
        proc.ld8Reg16AddrToReg(Reg.A, Reg16.HL)
        proc.inc16(Reg16.HL)
    })
    op[0x2B] = Instr(1, 8, "DEC HL", { proc.dec16(Reg16.HL) })
    op[0x2C] = Instr(1, 4, "INC L", { proc.inc(Reg.L) })
    op[0x2D] = Instr(1, 4, "DEC L", { proc.dec(Reg.L) })
    op[0x2E] = Instr(2, 8, "LD L, d8", { proc.ld8ImmValueToReg(Reg.L) })
    op[0x2F] = Instr(1, 4, "CPL", { proc.cpl() })
    op[0x30] = JmpInstr(2, 12, 8, "JR NC, r8", { proc.jrNC() })
    op[0x31] = VoidInstr(3, 12, "LD SP, d16", { cpu.sp = emu.read16(cpu.pc + 1) })
    op[0x32] = Instr(1, 8, "LD (HL-), A", {
        proc.ld8RegToReg16Addr(Reg16.HL, Reg.A)
        proc.dec16(Reg16.HL)
    })
    op[0x33] = VoidInstr(1, 8, "INC SP", { cpu.sp += 1 })
    op[0x34] = Instr(1, 12, "INC (HL)", { proc.incHL() })
    op[0x35] = Instr(1, 12, "DEC (HL)", { proc.decHL() })
    op[0x36] = VoidInstr(2, 12, "LD (HL), d8", {
        val addr = emu.read(cpu.pc + 1)
        proc.syncTimer(4)
        emu.write(cpu.readReg(Reg16.HL), addr)
    })
    op[0x37] = Instr(1, 4, "SCF", { proc.scf() })
    op[0x38] = JmpInstr(2, 12, 8, "JR C, r8", { proc.jrC() })
    op[0x39] = Instr(1, 8, "ADD HL, SP", { proc.addHLSP() })
    op[0x3A] = Instr(1, 8, "LD A, (HL-)", {
        proc.ld8Reg16AddrToReg(Reg.A, Reg16.HL)
        proc.dec16(Reg16.HL)
    })
    op[0x3B] = VoidInstr(1, 8, "DEC SP", { cpu.sp -= 1 })
    op[0x3C] = Instr(1, 4, "INC A", { proc.inc(Reg.A) })
    op[0x3D] = Instr(1, 4, "DEC A", { proc.dec(Reg.A) })
    op[0x3E] = Instr(2, 8, "LD A, d8", { proc.ld8ImmValueToReg(Reg.A) })
    op[0x3F] = Instr(1, 4, "CCF", { proc.ccf() })
    op[0x40] = Instr(1, 4, "LD B, B", { proc.ld(Reg.B, Reg.B) })
    op[0x41] = Instr(1, 4, "LD B, C", { proc.ld(Reg.B, Reg.C) })
    op[0x42] = Instr(1, 4, "LD B, D", { proc.ld(Reg.B, Reg.D) })
    op[0x43] = Instr(1, 4, "LD B, E", { proc.ld(Reg.B, Reg.E) })
    op[0x44] = Instr(1, 4, "LD B, H", { proc.ld(Reg.B, Reg.H) })
    op[0x45] = Instr(1, 4, "LD B, L", { proc.ld(Reg.B, Reg.L) })
    op[0x46] = Instr(1, 8, "LD B, (HL)", { proc.ld8Reg16AddrToReg(Reg.B, Reg16.HL) })
    op[0x47] = Instr(1, 4, "LD B, A", { proc.ld(Reg.B, Reg.A) })
    op[0x48] = Instr(1, 4, "LD C, B", { proc.ld(Reg.C, Reg.B) })
    op[0x49] = Instr(1, 4, "LD C, C", { proc.ld(Reg.C, Reg.C) })
    op[0x4A] = Instr(1, 4, "LD C, D", { proc.ld(Reg.C, Reg.D) })
    op[0x4B] = Instr(1, 4, "LD C, E", { proc.ld(Reg.C, Reg.E) })
    op[0x4C] = Instr(1, 4, "LD C, H", { proc.ld(Reg.C, Reg.H) })
    op[0x4D] = Instr(1, 4, "LD C, L", { proc.ld(Reg.C, Reg.L) })
    op[0x4E] = Instr(1, 8, "LD C, (HL)", { proc.ld8Reg16AddrToReg(Reg.C, Reg16.HL) })
    op[0x4F] = Instr(1, 4, "LD C, A", { proc.ld(Reg.C, Reg.A) })
    op[0x50] = Instr(1, 4, "LD D, B", { proc.ld(Reg.D, Reg.B) })
    op[0x51] = Instr(1, 4, "LD D, C", { proc.ld(Reg.D, Reg.C) })
    op[0x52] = Instr(1, 4, "LD D, D", { proc.ld(Reg.D, Reg.D) })
    op[0x53] = Instr(1, 4, "LD D, E", { proc.ld(Reg.D, Reg.E) })
    op[0x54] = Instr(1, 4, "LD D, H", { proc.ld(Reg.D, Reg.H) })
    op[0x55] = Instr(1, 4, "LD D, L", { proc.ld(Reg.D, Reg.L) })
    op[0x56] = Instr(1, 8, "LD D, (HL)", { proc.ld8Reg16AddrToReg(Reg.D, Reg16.HL) })
    op[0x57] = Instr(1, 4, "LD D, A", { proc.ld(Reg.D, Reg.A) })
    op[0x58] = Instr(1, 4, "LD E, B", { proc.ld(Reg.E, Reg.B) })
    op[0x59] = Instr(1, 4, "LD E, C", { proc.ld(Reg.E, Reg.C) })
    op[0x5A] = Instr(1, 4, "LD E, D", { proc.ld(Reg.E, Reg.D) })
    op[0x5B] = Instr(1, 4, "LD E, E", { proc.ld(Reg.E, Reg.E) })
    op[0x5C] = Instr(1, 4, "LD E, H", { proc.ld(Reg.E, Reg.H) })
    op[0x5D] = Instr(1, 4, "LD E, L", { proc.ld(Reg.E, Reg.L) })
    op[0x5E] = Instr(1, 8, "LD E, (HL)", { proc.ld8Reg16AddrToReg(Reg.E, Reg16.HL) })
    op[0x5F] = Instr(1, 4, "LD E, A", { proc.ld(Reg.E, Reg.A) })
    op[0x60] = Instr(1, 4, "LD H, B", { proc.ld(Reg.H, Reg.B) })
    op[0x61] = Instr(1, 4, "LD H, C", { proc.ld(Reg.H, Reg.C) })
    op[0x62] = Instr(1, 4, "LD H, D", { proc.ld(Reg.H, Reg.D) })
    op[0x63] = Instr(1, 4, "LD H, E", { proc.ld(Reg.H, Reg.E) })
    op[0x64] = Instr(1, 4, "LD H, H", { proc.ld(Reg.H, Reg.H) })
    op[0x65] = Instr(1, 4, "LD H, L", { proc.ld(Reg.H, Reg.L) })
    op[0x66] = Instr(1, 8, "LD H, (HL)", { proc.ld8Reg16AddrToReg(Reg.H, Reg16.HL) })
    op[0x67] = Instr(1, 4, "LD H, A", { proc.ld(Reg.H, Reg.A) })
    op[0x68] = Instr(1, 4, "LD L, B", { proc.ld(Reg.L, Reg.B) })
    op[0x69] = Instr(1, 4, "LD L, C", { proc.ld(Reg.L, Reg.C) })
    op[0x6A] = Instr(1, 4, "LD L, D", { proc.ld(Reg.L, Reg.D) })
    op[0x6B] = Instr(1, 4, "LD L, E", { proc.ld(Reg.L, Reg.E) })
    op[0x6C] = Instr(1, 4, "LD L, H", { proc.ld(Reg.L, Reg.H) })
    op[0x6D] = Instr(1, 4, "LD L, L", { proc.ld(Reg.L, Reg.L) })
    op[0x6E] = Instr(1, 8, "LD L, (HL)", { proc.ld8Reg16AddrToReg(Reg.L, Reg16.HL) })
    op[0x6F] = Instr(1, 4, "LD L, A", { proc.ld(Reg.L, Reg.A) })
    op[0x70] = Instr(1, 8, "LD (HL), B", { proc.ld8RegToReg16Addr(Reg16.HL, Reg.B) })
    op[0x71] = Instr(1, 8, "LD (HL), C", { proc.ld8RegToReg16Addr(Reg16.HL, Reg.C) })
    op[0x72] = Instr(1, 8, "LD (HL), D", { proc.ld8RegToReg16Addr(Reg16.HL, Reg.D) })
    op[0x73] = Instr(1, 8, "LD (HL), E", { proc.ld8RegToReg16Addr(Reg16.HL, Reg.E) })
    op[0x74] = Instr(1, 8, "LD (HL), H", { proc.ld8RegToReg16Addr(Reg16.HL, Reg.H) })
    op[0x75] = Instr(1, 8, "LD (HL), L", { proc.ld8RegToReg16Addr(Reg16.HL, Reg.L) })
    op[0x76] = VoidInstr(1, 4, "HALT", { cpu.halt = true })
    op[0x77] = Instr(1, 8, "LD (HL), A", { proc.ld8RegToReg16Addr(Reg16.HL, Reg.A) })
    op[0x78] = Instr(1, 4, "LD A, B", { proc.ld(Reg.A, Reg.B) })
    op[0x79] = Instr(1, 4, "LD A, C", { proc.ld(Reg.A, Reg.C) })
    op[0x7A] = Instr(1, 4, "LD A, D", { proc.ld(Reg.A, Reg.D) })
    op[0x7B] = Instr(1, 4, "LD A, E", { proc.ld(Reg.A, Reg.E) })
    op[0x7C] = Instr(1, 4, "LD A, H", { proc.ld(Reg.A, Reg.H) })
    op[0x7D] = Instr(1, 4, "LD A, L", { proc.ld(Reg.A, Reg.L) })
    op[0x7E] = Instr(1, 8, "LD A, (HL)", { proc.ld8Reg16AddrToReg(Reg.A, Reg16.HL) })
    op[0x7F] = Instr(1, 4, "LD A, A", { proc.ld(Reg.A, Reg.A) })
    op[0x80] = Instr(1, 4, "ADD A, B", { proc.addReg(Reg.B) })
    op[0x81] = Instr(1, 4, "ADD A, C", { proc.addReg(Reg.C) })
    op[0x82] = Instr(1, 4, "ADD A, D", { proc.addReg(Reg.D) })
    op[0x83] = Instr(1, 4, "ADD A, E", { proc.addReg(Reg.E) })
    op[0x84] = Instr(1, 4, "ADD A, H", { proc.addReg(Reg.H) })
    op[0x85] = Instr(1, 4, "ADD A, L", { proc.addReg(Reg.L) })
    op[0x86] = Instr(1, 8, "ADD A, (HL)", { proc.add(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0x87] = Instr(1, 4, "ADD A, A", { proc.addReg(Reg.A) })
    op[0x88] = Instr(1, 4, "ADC A, B", { proc.adcReg(Reg.B) })
    op[0x89] = Instr(1, 4, "ADC A, C", { proc.adcReg(Reg.C) })
    op[0x8A] = Instr(1, 4, "ADC A, D", { proc.adcReg(Reg.D) })
    op[0x8B] = Instr(1, 4, "ADC A, E", { proc.adcReg(Reg.E) })
    op[0x8C] = Instr(1, 4, "ADC A, H", { proc.adcReg(Reg.H) })
    op[0x8D] = Instr(1, 4, "ADC A, L", { proc.adcReg(Reg.L) })
    op[0x8E] = Instr(1, 8, "ADC A, (HL)", { proc.adc(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0x8F] = Instr(1, 4, "ADC A, A", { proc.adcReg(Reg.A) })
    op[0x90] = Instr(1, 4, "SUB B", { proc.subReg(Reg.B) })
    op[0x91] = Instr(1, 4, "SUB C", { proc.subReg(Reg.C) })
    op[0x92] = Instr(1, 4, "SUB D", { proc.subReg(Reg.D) })
    op[0x93] = Instr(1, 4, "SUB E", { proc.subReg(Reg.E) })
    op[0x94] = Instr(1, 4, "SUB H", { proc.subReg(Reg.H) })
    op[0x95] = Instr(1, 4, "SUB L", { proc.subReg(Reg.L) })
    op[0x96] = Instr(1, 8, "SUB (HL)", { proc.sub(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0x97] = Instr(1, 4, "SUB A", { proc.subReg(Reg.A) })
    op[0x98] = Instr(1, 4, "SBC A, B", { proc.sbcReg(Reg.B) })
    op[0x99] = Instr(1, 4, "SBC A, C", { proc.sbcReg(Reg.C) })
    op[0x9A] = Instr(1, 4, "SBC A, D", { proc.sbcReg(Reg.D) })
    op[0x9B] = Instr(1, 4, "SBC A, E", { proc.sbcReg(Reg.E) })
    op[0x9C] = Instr(1, 4, "SBC A, H", { proc.sbcReg(Reg.H) })
    op[0x9D] = Instr(1, 4, "SBC A, L", { proc.sbcReg(Reg.L) })
    op[0x9E] = Instr(1, 8, "SBC A, (HL)", { proc.sbc(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0x9F] = Instr(1, 4, "SBC A, A", { proc.sbcReg(Reg.A) })
    op[0xA0] = Instr(1, 4, "AND B", { proc.andReg(Reg.B) })
    op[0xA1] = Instr(1, 4, "AND C", { proc.andReg(Reg.C) })
    op[0xA2] = Instr(1, 4, "AND D", { proc.andReg(Reg.D) })
    op[0xA3] = Instr(1, 4, "AND E", { proc.andReg(Reg.E) })
    op[0xA4] = Instr(1, 4, "AND H", { proc.andReg(Reg.H) })
    op[0xA5] = Instr(1, 4, "AND L", { proc.andReg(Reg.L) })
    op[0xA6] = Instr(1, 8, "AND (HL)", { proc.and(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0xA7] = Instr(1, 4, "AND A", { proc.andReg(Reg.A) })
    op[0xA8] = Instr(1, 4, "XOR B", { proc.xorReg(Reg.B) })
    op[0xA9] = Instr(1, 4, "XOR C", { proc.xorReg(Reg.C) })
    op[0xAA] = Instr(1, 4, "XOR D", { proc.xorReg(Reg.D) })
    op[0xAB] = Instr(1, 4, "XOR E", { proc.xorReg(Reg.E) })
    op[0xAC] = Instr(1, 4, "XOR H", { proc.xorReg(Reg.H) })
    op[0xAD] = Instr(1, 4, "XOR L", { proc.xorReg(Reg.L) })
    op[0xAE] = Instr(1, 8, "XOR (HL)", { proc.xor(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0xAF] = Instr(1, 4, "XOR A", { proc.xorReg(Reg.A) })
    op[0xB0] = Instr(1, 4, "OR B", { proc.orReg(Reg.B) })
    op[0xB1] = Instr(1, 4, "OR C", { proc.orReg(Reg.C) })
    op[0xB2] = Instr(1, 4, "OR D", { proc.orReg(Reg.D) })
    op[0xB3] = Instr(1, 4, "OR E", { proc.orReg(Reg.E) })
    op[0xB4] = Instr(1, 4, "OR H", { proc.orReg(Reg.H) })
    op[0xB5] = Instr(1, 4, "OR L", { proc.orReg(Reg.L) })
    op[0xB6] = Instr(1, 8, "OR (HL)", { proc.or(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0xB7] = Instr(1, 4, "OR A", { proc.orReg(Reg.A) })
    op[0xB8] = Instr(1, 4, "CP B", { proc.cpReg(Reg.B) })
    op[0xB9] = Instr(1, 4, "CP C", { proc.cpReg(Reg.C) })
    op[0xBA] = Instr(1, 4, "CP D", { proc.cpReg(Reg.D) })
    op[0xBB] = Instr(1, 4, "CP E", { proc.cpReg(Reg.E) })
    op[0xBC] = Instr(1, 4, "CP H", { proc.cpReg(Reg.H) })
    op[0xBD] = Instr(1, 4, "CP L", { proc.cpReg(Reg.L) })
    op[0xBE] = Instr(1, 8, "CP (HL)", { proc.cp(emu.readInt(cpu.readReg(Reg16.HL))) })
    op[0xBF] = Instr(1, 4, "CP A", { proc.cpReg(Reg.A) })
    op[0xC0] = JmpInstr(1, 20, 8, "RET NZ", { proc.retNZ() })
    op[0xC1] = Instr(1, 12, "POP BC", { proc.popReg(Reg16.BC) })
    op[0xC2] = JmpInstr(3, 16, 12, "JP NZ, a16", { proc.jpNZ() })
    op[0xC3] = JmpInstr(3, 16, 16, "JP a16", { proc.jp() })
    op[0xC4] = JmpInstr(3, 24, 12, "CALL NZ, a16", { proc.callNZ() })
    op[0xC5] = Instr(1, 16, "PUSH BC", { proc.pushReg(Reg16.BC) })
    op[0xC6] = Instr(2, 8, "ADD A, d8", { proc.add(emu.readInt(cpu.pc + 1)) })
    op[0xC7] = JmpInstr(1, 16, 16, "RST 00H", { proc.rst(0x00) })
    op[0xC8] = JmpInstr(1, 20, 8, "RET Z", { proc.retZ() })
    op[0xC9] = JmpInstr(1, 16, 16, "RET", { proc.ret() })
    op[0xCA] = JmpInstr(3, 16, 12, "JP Z, a16", { proc.jpZ() })
    op[0xCB] = Instr(1, 4, "PREFIX CB", { throw EmulatorException("Reserved opcode, call instruction from CB opcode table") })
    op[0xCC] = JmpInstr(3, 24, 12, "CALL Z, a16", { proc.callZ() })
    op[0xCD] = JmpInstr(3, 24, 24, "CALL a16", { proc.call() })
    op[0xCE] = Instr(2, 8, "ADC A, d8", { proc.adc(emu.readInt(cpu.pc + 1)) })
    op[0xCF] = JmpInstr(1, 16, 16, "RST 08H", { proc.rst(0x08) })
    op[0xD0] = JmpInstr(1, 20, 8, "RET NC", { proc.retNC() })
    op[0xD1] = Instr(1, 12, "POP DE", { proc.popReg(Reg16.DE) })
    op[0xD2] = JmpInstr(3, 16, 12, "JP NC, a16", { proc.jpNC() })
    op[0xD3] = null
    op[0xD4] = JmpInstr(3, 24, 12, "CALL NC, a16", { proc.callNC() })
    op[0xD5] = Instr(1, 16, "PUSH DE", { proc.pushReg(Reg16.DE) })
    op[0xD6] = Instr(2, 8, "SUB d8", { proc.sub(emu.readInt(cpu.pc + 1)) })
    op[0xD7] = JmpInstr(1, 16, 16, "RST 10H", { proc.rst(0x10) })
    op[0xD8] = JmpInstr(1, 20, 8, "RET C", { proc.retC() })
    op[0xD9] = JmpInstr(1, 16, 16, "RETI", { proc.reti() })
    op[0xDA] = JmpInstr(3, 16, 12, "JP C, a16", { proc.jpC() })
    op[0xDB] = null
    op[0xDC] = JmpInstr(3, 24, 12, "CALL C, a16", { proc.callC() })
    op[0xDD] = null
    op[0xDE] = Instr(2, 8, "SBC A, d8", { proc.sbc(emu.readInt(cpu.pc + 1)) })
    op[0xDF] = JmpInstr(1, 16, 16, "RST 18H", { proc.rst(0x18) })
    op[0xE0] = Instr(2, 12, "LDH (a8), A", {
        val addr = 0xFF00 + emu.readInt(cpu.pc + 1)
        proc.syncTimer(4)
        proc.ld8RegToAddr(addr, Reg.A)
    })
    op[0xE1] = Instr(1, 12, "POP HL", { proc.popReg(Reg16.HL) })
    op[0xE2] = Instr(1, 8, "LD (C), A", { proc.ld8RegToAddr(0xFF00 + cpu.readRegInt(Reg.C), Reg.A) })
    op[0xE3] = null
    op[0xE4] = null
    op[0xE5] = Instr(1, 16, "PUSH HL", { proc.pushReg(Reg16.HL) })
    op[0xE6] = Instr(2, 8, "AND d8", { proc.and(emu.readInt(cpu.pc + 1)) })
    op[0xE7] = JmpInstr(1, 16, 16, "RST 20H", { proc.rst(0x20) })
    op[0xE8] = VoidInstr(2, 16, "ADD SP, r8", {
        val value = emu.read(cpu.pc + 1).toInt() //r8 is signed here lol
        val sp = cpu.sp + value
        cpu.resetFlag(Flag.Z)
        cpu.resetFlag(Flag.N)

        //the only answer https://stackoverflow.com/questions/5159603/gbz80-how-does-ld-hl-spe-affect-h-and-c-flags
        if ((cpu.sp and 0xF) + (value and 0xF) and 0x10 != 0) cpu.setFlag(Flag.H) else cpu.resetFlag(Flag.H)
        if ((cpu.sp and 0xFF) + (value and 0xFF) and 0x100 != 0) cpu.setFlag(Flag.C) else cpu.resetFlag(Flag.C)

        cpu.sp = sp
    })
    op[0xE9] = JmpInstr(1, 4, 4, "JP (HL)", { proc.jpHL() })
    op[0xEA] = Instr(3, 16, "LD (a16), A", { proc.ld8RegToImmAddr(Reg.A) })
    op[0xEB] = null
    op[0xEC] = null
    op[0xED] = null
    op[0xEE] = Instr(2, 8, "XOR d8", { proc.xor(emu.readInt(cpu.pc + 1)) })
    op[0xEF] = JmpInstr(1, 16, 16, "RST 28H", { proc.rst(0x28) })
    op[0xF0] = Instr(2, 12, "LDH A, (a8)", {
        val addr = 0xFF00 + emu.readInt(cpu.pc + 1)
        proc.syncTimer(4)
        proc.ld8AddrToReg(Reg.A, addr)
    })
    op[0xF1] = Instr(1, 12, "POP AF", { proc.popReg(Reg16.AF) })
    op[0xF2] = Instr(1, 8, "LD A, (C)", { proc.ld8AddrToReg(Reg.A, 0xFF00 + cpu.readRegInt(Reg.C)) })
    op[0xF3] = VoidInstr(1, 4, "DI", { cpu.setImeFlag(false) })
    op[0xF4] = null
    op[0xF5] = Instr(1, 16, "PUSH AF", { proc.pushReg(Reg16.AF) })
    op[0xF6] = Instr(2, 8, "OR d8", { proc.or(emu.readInt(cpu.pc + 1)) })
    op[0xF7] = JmpInstr(1, 16, 16, "RST 30H", { proc.rst(0x30) })
    op[0xF8] = VoidInstr(2, 12, "LD HL, SP+r8", {
        val value = emu.read(cpu.pc + 1).toInt()

        cpu.resetFlag(Flag.Z)
        cpu.resetFlag(Flag.N)
        if ((cpu.sp and 0xF) + (value and 0xF) and 0x10 != 0) cpu.setFlag(Flag.H) else cpu.resetFlag(Flag.H)
        if ((cpu.sp and 0xFF) + (value and 0xFF) and 0x100 != 0) cpu.setFlag(Flag.C) else cpu.resetFlag(Flag.C)

        cpu.writeReg(Reg16.HL, cpu.sp + value)
    })
    op[0xF9] = VoidInstr(1, 8, "LD SP, HL", { cpu.sp = cpu.readReg(Reg16.HL) })
    op[0xFA] = Instr(3, 16, "LD A, (a16)", { proc.ld8ImmAddrToReg(Reg.A) })
    op[0xFB] = VoidInstr(1, 4, "EI", { cpu.setImeFlag(true) })
    op[0xFC] = null
    op[0xFD] = null
    op[0xFE] = Instr(2, 8, "CP d8", { proc.cp(emu.readInt(cpu.pc + 1)) })
    op[0xFF] = JmpInstr(1, 16, 16, "RST 38H", { proc.rst(0x38) })
}

fun generateExtOpCodes(emu: Emulator, cpu: Cpu, proc: OpCodesProcessor, op: Array<Instr?>) {
    op[0x00] = Instr(2, 8, "RLC B", { proc.rlcReg(Reg.B) })
    op[0x01] = Instr(2, 8, "RLC C", { proc.rlcReg(Reg.C) })
    op[0x02] = Instr(2, 8, "RLC D", { proc.rlcReg(Reg.D) })
    op[0x03] = Instr(2, 8, "RLC E", { proc.rlcReg(Reg.E) })
    op[0x04] = Instr(2, 8, "RLC H", { proc.rlcReg(Reg.H) })
    op[0x05] = Instr(2, 8, "RLC L", { proc.rlcReg(Reg.L) })
    op[0x06] = Instr(2, 16, "RLC (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.rlc(emu.read(addr), true))
    })
    op[0x07] = Instr(2, 8, "RLC A", { proc.rlcReg(Reg.A) })
    op[0x08] = Instr(2, 8, "RRC B", { proc.rrcReg(Reg.B) })
    op[0x09] = Instr(2, 8, "RRC C", { proc.rrcReg(Reg.C) })
    op[0x0A] = Instr(2, 8, "RRC D", { proc.rrcReg(Reg.D) })
    op[0x0B] = Instr(2, 8, "RRC E", { proc.rrcReg(Reg.E) })
    op[0x0C] = Instr(2, 8, "RRC H", { proc.rrcReg(Reg.H) })
    op[0x0D] = Instr(2, 8, "RRC L", { proc.rrcReg(Reg.L) })
    op[0x0E] = Instr(2, 16, "RRC (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.rrc(emu.read(addr), true))
    })
    op[0x0F] = Instr(2, 8, "RRC A", { proc.rrcReg(Reg.A) })
    op[0x10] = Instr(2, 8, "RL B", { proc.rlReg(Reg.B) })
    op[0x11] = Instr(2, 8, "RL C", { proc.rlReg(Reg.C) })
    op[0x12] = Instr(2, 8, "RL D", { proc.rlReg(Reg.D) })
    op[0x13] = Instr(2, 8, "RL E", { proc.rlReg(Reg.E) })
    op[0x14] = Instr(2, 8, "RL H", { proc.rlReg(Reg.H) })
    op[0x15] = Instr(2, 8, "RL L", { proc.rlReg(Reg.L) })
    op[0x16] = Instr(2, 16, "RL (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.rl(emu.read(addr), true))
    })
    op[0x17] = Instr(2, 8, "RL A", { proc.rlReg(Reg.A) })
    op[0x18] = Instr(2, 8, "RR B", { proc.rrReg(Reg.B) })
    op[0x19] = Instr(2, 8, "RR C", { proc.rrReg(Reg.C) })
    op[0x1A] = Instr(2, 8, "RR D", { proc.rrReg(Reg.D) })
    op[0x1B] = Instr(2, 8, "RR E", { proc.rrReg(Reg.E) })
    op[0x1C] = Instr(2, 8, "RR H", { proc.rrReg(Reg.H) })
    op[0x1D] = Instr(2, 8, "RR L", { proc.rrReg(Reg.L) })
    op[0x1E] = Instr(2, 16, "RR (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.rr(emu.read(addr), true))
    })
    op[0x1F] = Instr(2, 8, "RR A", { proc.rrReg(Reg.A) })
    op[0x20] = Instr(2, 8, "SLA B", { proc.slaReg(Reg.B) })
    op[0x21] = Instr(2, 8, "SLA C", { proc.slaReg(Reg.C) })
    op[0x22] = Instr(2, 8, "SLA D", { proc.slaReg(Reg.D) })
    op[0x23] = Instr(2, 8, "SLA E", { proc.slaReg(Reg.E) })
    op[0x24] = Instr(2, 8, "SLA H", { proc.slaReg(Reg.H) })
    op[0x25] = Instr(2, 8, "SLA L", { proc.slaReg(Reg.L) })
    op[0x26] = Instr(2, 16, "SLA (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.sla(emu.read(addr)))
    })
    op[0x27] = Instr(2, 8, "SLA A", { proc.slaReg(Reg.A) })
    op[0x28] = Instr(2, 8, "SRA B", { proc.sraReg(Reg.B) })
    op[0x29] = Instr(2, 8, "SRA C", { proc.sraReg(Reg.C) })
    op[0x2A] = Instr(2, 8, "SRA D", { proc.sraReg(Reg.D) })
    op[0x2B] = Instr(2, 8, "SRA E", { proc.sraReg(Reg.E) })
    op[0x2C] = Instr(2, 8, "SRA H", { proc.sraReg(Reg.H) })
    op[0x2D] = Instr(2, 8, "SRA L", { proc.sraReg(Reg.L) })
    op[0x2E] = Instr(2, 16, "SRA (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.sra(emu.read(addr)))
    })
    op[0x2F] = Instr(2, 8, "SRA A", { proc.sraReg(Reg.A) })
    op[0x30] = Instr(2, 8, "SWAP B", { proc.swapReg(Reg.B) })
    op[0x31] = Instr(2, 8, "SWAP C", { proc.swapReg(Reg.C) })
    op[0x32] = Instr(2, 8, "SWAP D", { proc.swapReg(Reg.D) })
    op[0x33] = Instr(2, 8, "SWAP E", { proc.swapReg(Reg.E) })
    op[0x34] = Instr(2, 8, "SWAP H", { proc.swapReg(Reg.H) })
    op[0x35] = Instr(2, 8, "SWAP L", { proc.swapReg(Reg.L) })
    op[0x36] = Instr(2, 16, "SWAP (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.swap(emu.read(addr)))
    })
    op[0x37] = Instr(2, 8, "SWAP A", { proc.swapReg(Reg.A) })
    op[0x38] = Instr(2, 8, "SRL B", { proc.srlReg(Reg.B) })
    op[0x39] = Instr(2, 8, "SRL C", { proc.srlReg(Reg.C) })
    op[0x3A] = Instr(2, 8, "SRL D", { proc.srlReg(Reg.D) })
    op[0x3B] = Instr(2, 8, "SRL E", { proc.srlReg(Reg.E) })
    op[0x3C] = Instr(2, 8, "SRL H", { proc.srlReg(Reg.H) })
    op[0x3D] = Instr(2, 8, "SRL L", { proc.srlReg(Reg.L) })
    op[0x3E] = Instr(2, 16, "SRL (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.srl(emu.read(addr)))
    })
    op[0x3F] = Instr(2, 8, "SRL A", { proc.srlReg(Reg.A) })
    op[0x40] = Instr(2, 8, "BIT 0, B", { proc.bitReg(0, Reg.B) })
    op[0x41] = Instr(2, 8, "BIT 0, C", { proc.bitReg(0, Reg.C) })
    op[0x42] = Instr(2, 8, "BIT 0, D", { proc.bitReg(0, Reg.D) })
    op[0x43] = Instr(2, 8, "BIT 0, E", { proc.bitReg(0, Reg.E) })
    op[0x44] = Instr(2, 8, "BIT 0, H", { proc.bitReg(0, Reg.H) })
    op[0x45] = Instr(2, 8, "BIT 0, L", { proc.bitReg(0, Reg.L) })
    op[0x46] = Instr(2, 12, "BIT 0, (HL)", { proc.bitHL(0) })
    op[0x47] = Instr(2, 8, "BIT 0, A", { proc.bitReg(0, Reg.A) })
    op[0x48] = Instr(2, 8, "BIT 1, B", { proc.bitReg(1, Reg.B) })
    op[0x49] = Instr(2, 8, "BIT 1, C", { proc.bitReg(1, Reg.C) })
    op[0x4A] = Instr(2, 8, "BIT 1, D", { proc.bitReg(1, Reg.D) })
    op[0x4B] = Instr(2, 8, "BIT 1, E", { proc.bitReg(1, Reg.E) })
    op[0x4C] = Instr(2, 8, "BIT 1, H", { proc.bitReg(1, Reg.H) })
    op[0x4D] = Instr(2, 8, "BIT 1, L", { proc.bitReg(1, Reg.L) })
    op[0x4E] = Instr(2, 12, "BIT 1, (HL)", { proc.bitHL(1) })
    op[0x4F] = Instr(2, 8, "BIT 1, A", { proc.bitReg(1, Reg.A) })
    op[0x50] = Instr(2, 8, "BIT 2, B", { proc.bitReg(2, Reg.B) })
    op[0x51] = Instr(2, 8, "BIT 2, C", { proc.bitReg(2, Reg.C) })
    op[0x52] = Instr(2, 8, "BIT 2, D", { proc.bitReg(2, Reg.D) })
    op[0x53] = Instr(2, 8, "BIT 2, E", { proc.bitReg(2, Reg.E) })
    op[0x54] = Instr(2, 8, "BIT 2, H", { proc.bitReg(2, Reg.H) })
    op[0x55] = Instr(2, 8, "BIT 2, L", { proc.bitReg(2, Reg.L) })
    op[0x56] = Instr(2, 12, "BIT 2, (HL)", { proc.bitHL(2) })
    op[0x57] = Instr(2, 8, "BIT 2, A", { proc.bitReg(2, Reg.A) })
    op[0x58] = Instr(2, 8, "BIT 3, B", { proc.bitReg(3, Reg.B) })
    op[0x59] = Instr(2, 8, "BIT 3, C", { proc.bitReg(3, Reg.C) })
    op[0x5A] = Instr(2, 8, "BIT 3, D", { proc.bitReg(3, Reg.D) })
    op[0x5B] = Instr(2, 8, "BIT 3, E", { proc.bitReg(3, Reg.E) })
    op[0x5C] = Instr(2, 8, "BIT 3, H", { proc.bitReg(3, Reg.H) })
    op[0x5D] = Instr(2, 8, "BIT 3, L", { proc.bitReg(3, Reg.L) })
    op[0x5E] = Instr(2, 12, "BIT 3, (HL)", { proc.bitHL(3) })
    op[0x5F] = Instr(2, 8, "BIT 3, A", { proc.bitReg(3, Reg.A) })
    op[0x60] = Instr(2, 8, "BIT 4, B", { proc.bitReg(4, Reg.B) })
    op[0x61] = Instr(2, 8, "BIT 4, C", { proc.bitReg(4, Reg.C) })
    op[0x62] = Instr(2, 8, "BIT 4, D", { proc.bitReg(4, Reg.D) })
    op[0x63] = Instr(2, 8, "BIT 4, E", { proc.bitReg(4, Reg.E) })
    op[0x64] = Instr(2, 8, "BIT 4, H", { proc.bitReg(4, Reg.H) })
    op[0x65] = Instr(2, 8, "BIT 4, L", { proc.bitReg(4, Reg.L) })
    op[0x66] = Instr(2, 12, "BIT 4, (HL)", { proc.bitHL(4) })
    op[0x67] = Instr(2, 8, "BIT 4, A", { proc.bitReg(4, Reg.A) })
    op[0x68] = Instr(2, 8, "BIT 5, B", { proc.bitReg(5, Reg.B) })
    op[0x69] = Instr(2, 8, "BIT 5, C", { proc.bitReg(5, Reg.C) })
    op[0x6A] = Instr(2, 8, "BIT 5, D", { proc.bitReg(5, Reg.D) })
    op[0x6B] = Instr(2, 8, "BIT 5, E", { proc.bitReg(5, Reg.E) })
    op[0x6C] = Instr(2, 8, "BIT 5, H", { proc.bitReg(5, Reg.H) })
    op[0x6D] = Instr(2, 8, "BIT 5, L", { proc.bitReg(5, Reg.L) })
    op[0x6E] = Instr(2, 12, "BIT 5, (HL)", { proc.bitHL(5) })
    op[0x6F] = Instr(2, 8, "BIT 5, A", { proc.bitReg(5, Reg.A) })
    op[0x70] = Instr(2, 8, "BIT 6, B", { proc.bitReg(6, Reg.B) })
    op[0x71] = Instr(2, 8, "BIT 6, C", { proc.bitReg(6, Reg.C) })
    op[0x72] = Instr(2, 8, "BIT 6, D", { proc.bitReg(6, Reg.D) })
    op[0x73] = Instr(2, 8, "BIT 6, E", { proc.bitReg(6, Reg.E) })
    op[0x74] = Instr(2, 8, "BIT 6, H", { proc.bitReg(6, Reg.H) })
    op[0x75] = Instr(2, 8, "BIT 6, L", { proc.bitReg(6, Reg.L) })
    op[0x76] = Instr(2, 12, "BIT 6, (HL)", { proc.bitHL(6) })
    op[0x77] = Instr(2, 8, "BIT 6, A", { proc.bitReg(6, Reg.A) })
    op[0x78] = Instr(2, 8, "BIT 7, B", { proc.bitReg(7, Reg.B) })
    op[0x79] = Instr(2, 8, "BIT 7, C", { proc.bitReg(7, Reg.C) })
    op[0x7A] = Instr(2, 8, "BIT 7, D", { proc.bitReg(7, Reg.D) })
    op[0x7B] = Instr(2, 8, "BIT 7, E", { proc.bitReg(7, Reg.E) })
    op[0x7C] = Instr(2, 8, "BIT 7, H", { proc.bitReg(7, Reg.H) })
    op[0x7D] = Instr(2, 8, "BIT 7, L", { proc.bitReg(7, Reg.L) })
    op[0x7E] = Instr(2, 12, "BIT 7, (HL)", { proc.bitHL(7) })
    op[0x7F] = Instr(2, 8, "BIT 7, A", { proc.bitReg(7, Reg.A) })
    op[0x80] = Instr(2, 8, "RES 0, B", { proc.resReg(0, Reg.B) })
    op[0x81] = Instr(2, 8, "RES 0, C", { proc.resReg(0, Reg.C) })
    op[0x82] = Instr(2, 8, "RES 0, D", { proc.resReg(0, Reg.D) })
    op[0x83] = Instr(2, 8, "RES 0, E", { proc.resReg(0, Reg.E) })
    op[0x84] = Instr(2, 8, "RES 0, H", { proc.resReg(0, Reg.H) })
    op[0x85] = Instr(2, 8, "RES 0, L", { proc.resReg(0, Reg.L) })
    op[0x86] = Instr(2, 16, "RES 0, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(0, emu.read(addr)))
    })
    op[0x87] = Instr(2, 8, "RES 0, A", { proc.resReg(0, Reg.A) })
    op[0x88] = Instr(2, 8, "RES 1, B", { proc.resReg(1, Reg.B) })
    op[0x89] = Instr(2, 8, "RES 1, C", { proc.resReg(1, Reg.C) })
    op[0x8A] = Instr(2, 8, "RES 1, D", { proc.resReg(1, Reg.D) })
    op[0x8B] = Instr(2, 8, "RES 1, E", { proc.resReg(1, Reg.E) })
    op[0x8C] = Instr(2, 8, "RES 1, H", { proc.resReg(1, Reg.H) })
    op[0x8D] = Instr(2, 8, "RES 1, L", { proc.resReg(1, Reg.L) })
    op[0x8E] = Instr(2, 16, "RES 1, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(1, emu.read(addr)))
    })
    op[0x8F] = Instr(2, 8, "RES 1, A", { proc.resReg(1, Reg.A) })
    op[0x90] = Instr(2, 8, "RES 2, B", { proc.resReg(2, Reg.B) })
    op[0x91] = Instr(2, 8, "RES 2, C", { proc.resReg(2, Reg.C) })
    op[0x92] = Instr(2, 8, "RES 2, D", { proc.resReg(2, Reg.D) })
    op[0x93] = Instr(2, 8, "RES 2, E", { proc.resReg(2, Reg.E) })
    op[0x94] = Instr(2, 8, "RES 2, H", { proc.resReg(2, Reg.H) })
    op[0x95] = Instr(2, 8, "RES 2, L", { proc.resReg(2, Reg.L) })
    op[0x96] = Instr(2, 16, "RES 2, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(2, emu.read(addr)))
    })
    op[0x97] = Instr(2, 8, "RES 2, A", { proc.resReg(2, Reg.A) })
    op[0x98] = Instr(2, 8, "RES 3, B", { proc.resReg(3, Reg.B) })
    op[0x99] = Instr(2, 8, "RES 3, C", { proc.resReg(3, Reg.C) })
    op[0x9A] = Instr(2, 8, "RES 3, D", { proc.resReg(3, Reg.D) })
    op[0x9B] = Instr(2, 8, "RES 3, E", { proc.resReg(3, Reg.E) })
    op[0x9C] = Instr(2, 8, "RES 3, H", { proc.resReg(3, Reg.H) })
    op[0x9D] = Instr(2, 8, "RES 3, L", { proc.resReg(3, Reg.L) })
    op[0x9E] = Instr(2, 16, "RES 3, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(3, emu.read(addr)))
    })
    op[0x9F] = Instr(2, 8, "RES 3, A", { proc.resReg(3, Reg.A) })
    op[0xA0] = Instr(2, 8, "RES 4, B", { proc.resReg(4, Reg.B) })
    op[0xA1] = Instr(2, 8, "RES 4, C", { proc.resReg(4, Reg.C) })
    op[0xA2] = Instr(2, 8, "RES 4, D", { proc.resReg(4, Reg.D) })
    op[0xA3] = Instr(2, 8, "RES 4, E", { proc.resReg(4, Reg.E) })
    op[0xA4] = Instr(2, 8, "RES 4, H", { proc.resReg(4, Reg.H) })
    op[0xA5] = Instr(2, 8, "RES 4, L", { proc.resReg(4, Reg.L) })
    op[0xA6] = Instr(2, 16, "RES 4, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(4, emu.read(addr)))
    })
    op[0xA7] = Instr(2, 8, "RES 4, A", { proc.resReg(4, Reg.A) })
    op[0xA8] = Instr(2, 8, "RES 5, B", { proc.resReg(5, Reg.B) })
    op[0xA9] = Instr(2, 8, "RES 5, C", { proc.resReg(5, Reg.C) })
    op[0xAA] = Instr(2, 8, "RES 5, D", { proc.resReg(5, Reg.D) })
    op[0xAB] = Instr(2, 8, "RES 5, E", { proc.resReg(5, Reg.E) })
    op[0xAC] = Instr(2, 8, "RES 5, H", { proc.resReg(5, Reg.H) })
    op[0xAD] = Instr(2, 8, "RES 5, L", { proc.resReg(5, Reg.L) })
    op[0xAE] = Instr(2, 16, "RES 5, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(5, emu.read(addr)))
    })
    op[0xAF] = Instr(2, 8, "RES 5, A", { proc.resReg(5, Reg.A) })
    op[0xB0] = Instr(2, 8, "RES 6, B", { proc.resReg(6, Reg.B) })
    op[0xB1] = Instr(2, 8, "RES 6, C", { proc.resReg(6, Reg.C) })
    op[0xB2] = Instr(2, 8, "RES 6, D", { proc.resReg(6, Reg.D) })
    op[0xB3] = Instr(2, 8, "RES 6, E", { proc.resReg(6, Reg.E) })
    op[0xB4] = Instr(2, 8, "RES 6, H", { proc.resReg(6, Reg.H) })
    op[0xB5] = Instr(2, 8, "RES 6, L", { proc.resReg(6, Reg.L) })
    op[0xB6] = Instr(2, 16, "RES 6, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(6, emu.read(addr)))
    })
    op[0xB7] = Instr(2, 8, "RES 6, A", { proc.resReg(6, Reg.A) })
    op[0xB8] = Instr(2, 8, "RES 7, B", { proc.resReg(7, Reg.B) })
    op[0xB9] = Instr(2, 8, "RES 7, C", { proc.resReg(7, Reg.C) })
    op[0xBA] = Instr(2, 8, "RES 7, D", { proc.resReg(7, Reg.D) })
    op[0xBB] = Instr(2, 8, "RES 7, E", { proc.resReg(7, Reg.E) })
    op[0xBC] = Instr(2, 8, "RES 7, H", { proc.resReg(7, Reg.H) })
    op[0xBD] = Instr(2, 8, "RES 7, L", { proc.resReg(7, Reg.L) })
    op[0xBE] = Instr(2, 16, "RES 7, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.res(7, emu.read(addr)))
    })
    op[0xBF] = Instr(2, 8, "RES 7, A", { proc.resReg(7, Reg.A) })
    op[0xC0] = Instr(2, 8, "SET 0, B", { proc.setReg(0, Reg.B) })
    op[0xC1] = Instr(2, 8, "SET 0, C", { proc.setReg(0, Reg.C) })
    op[0xC2] = Instr(2, 8, "SET 0, D", { proc.setReg(0, Reg.D) })
    op[0xC3] = Instr(2, 8, "SET 0, E", { proc.setReg(0, Reg.E) })
    op[0xC4] = Instr(2, 8, "SET 0, H", { proc.setReg(0, Reg.H) })
    op[0xC5] = Instr(2, 8, "SET 0, L", { proc.setReg(0, Reg.L) })
    op[0xC6] = Instr(2, 16, "SET 0, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(0, emu.read(addr)))
    })
    op[0xC7] = Instr(2, 8, "SET 0, A", { proc.setReg(0, Reg.A) })
    op[0xC8] = Instr(2, 8, "SET 1, B", { proc.setReg(1, Reg.B) })
    op[0xC9] = Instr(2, 8, "SET 1, C", { proc.setReg(1, Reg.C) })
    op[0xCA] = Instr(2, 8, "SET 1, D", { proc.setReg(1, Reg.D) })
    op[0xCB] = Instr(2, 8, "SET 1, E", { proc.setReg(1, Reg.E) })
    op[0xCC] = Instr(2, 8, "SET 1, H", { proc.setReg(1, Reg.H) })
    op[0xCD] = Instr(2, 8, "SET 1, L", { proc.setReg(1, Reg.L) })
    op[0xCE] = Instr(2, 16, "SET 1, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(1, emu.read(addr)))
    })
    op[0xCF] = Instr(2, 8, "SET 1, A", { proc.setReg(1, Reg.A) })
    op[0xD0] = Instr(2, 8, "SET 2, B", { proc.setReg(2, Reg.B) })
    op[0xD1] = Instr(2, 8, "SET 2, C", { proc.setReg(2, Reg.C) })
    op[0xD2] = Instr(2, 8, "SET 2, D", { proc.setReg(2, Reg.D) })
    op[0xD3] = Instr(2, 8, "SET 2, E", { proc.setReg(2, Reg.E) })
    op[0xD4] = Instr(2, 8, "SET 2, H", { proc.setReg(2, Reg.H) })
    op[0xD5] = Instr(2, 8, "SET 2, L", { proc.setReg(2, Reg.L) })
    op[0xD6] = Instr(2, 16, "SET 2, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(2, emu.read(addr)))
    })
    op[0xD7] = Instr(2, 8, "SET 2, A", { proc.setReg(2, Reg.A) })
    op[0xD8] = Instr(2, 8, "SET 3, B", { proc.setReg(3, Reg.B) })
    op[0xD9] = Instr(2, 8, "SET 3, C", { proc.setReg(3, Reg.C) })
    op[0xDA] = Instr(2, 8, "SET 3, D", { proc.setReg(3, Reg.D) })
    op[0xDB] = Instr(2, 8, "SET 3, E", { proc.setReg(3, Reg.E) })
    op[0xDC] = Instr(2, 8, "SET 3, H", { proc.setReg(3, Reg.H) })
    op[0xDD] = Instr(2, 8, "SET 3, L", { proc.setReg(3, Reg.L) })
    op[0xDE] = Instr(2, 16, "SET 3, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(3, emu.read(addr)))
    })
    op[0xDF] = Instr(2, 8, "SET 3, A", { proc.setReg(3, Reg.A) })
    op[0xE0] = Instr(2, 8, "SET 4, B", { proc.setReg(4, Reg.B) })
    op[0xE1] = Instr(2, 8, "SET 4, C", { proc.setReg(4, Reg.C) })
    op[0xE2] = Instr(2, 8, "SET 4, D", { proc.setReg(4, Reg.D) })
    op[0xE3] = Instr(2, 8, "SET 4, E", { proc.setReg(4, Reg.E) })
    op[0xE4] = Instr(2, 8, "SET 4, H", { proc.setReg(4, Reg.H) })
    op[0xE5] = Instr(2, 8, "SET 4, L", { proc.setReg(4, Reg.L) })
    op[0xE6] = Instr(2, 16, "SET 4, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(4, emu.read(addr)))
    })
    op[0xE7] = Instr(2, 8, "SET 4, A", { proc.setReg(4, Reg.A) })
    op[0xE8] = Instr(2, 8, "SET 5, B", { proc.setReg(5, Reg.B) })
    op[0xE9] = Instr(2, 8, "SET 5, C", { proc.setReg(5, Reg.C) })
    op[0xEA] = Instr(2, 8, "SET 5, D", { proc.setReg(5, Reg.D) })
    op[0xEB] = Instr(2, 8, "SET 5, E", { proc.setReg(5, Reg.E) })
    op[0xEC] = Instr(2, 8, "SET 5, H", { proc.setReg(5, Reg.H) })
    op[0xED] = Instr(2, 8, "SET 5, L", { proc.setReg(5, Reg.L) })
    op[0xEE] = Instr(2, 16, "SET 5, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(5, emu.read(addr)))
    })
    op[0xEF] = Instr(2, 8, "SET 5, A", { proc.setReg(5, Reg.A) })
    op[0xF0] = Instr(2, 8, "SET 6, B", { proc.setReg(6, Reg.B) })
    op[0xF1] = Instr(2, 8, "SET 6, C", { proc.setReg(6, Reg.C) })
    op[0xF2] = Instr(2, 8, "SET 6, D", { proc.setReg(6, Reg.D) })
    op[0xF3] = Instr(2, 8, "SET 6, E", { proc.setReg(6, Reg.E) })
    op[0xF4] = Instr(2, 8, "SET 6, H", { proc.setReg(6, Reg.H) })
    op[0xF5] = Instr(2, 8, "SET 6, L", { proc.setReg(6, Reg.L) })
    op[0xF6] = Instr(2, 16, "SET 6, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(6, emu.read(addr)))
    })
    op[0xF7] = Instr(2, 8, "SET 6, A", { proc.setReg(6, Reg.A) })
    op[0xF8] = Instr(2, 8, "SET 7, B", { proc.setReg(7, Reg.B) })
    op[0xF9] = Instr(2, 8, "SET 7, C", { proc.setReg(7, Reg.C) })
    op[0xFA] = Instr(2, 8, "SET 7, D", { proc.setReg(7, Reg.D) })
    op[0xFB] = Instr(2, 8, "SET 7, E", { proc.setReg(7, Reg.E) })
    op[0xFC] = Instr(2, 8, "SET 7, H", { proc.setReg(7, Reg.H) })
    op[0xFD] = Instr(2, 8, "SET 7, L", { proc.setReg(7, Reg.L) })
    op[0xFE] = Instr(2, 16, "SET 7, (HL)", {
        val addr = cpu.readReg(Reg16.HL)
        emu.write(addr, proc.set(7, emu.read(addr)))
    })
    op[0xFF] = Instr(2, 8, "SET 7, A", { proc.setReg(7, Reg.A) })
}
